//+------------------------------------------------------------------+\n//|                                        TheAlien.mq5              |\n//|  Moving Average - Improved EA (Risk-managed, ATR & Trend filter)|\n//|  Duplicate of MuvAv_Preh4uzd with new name TheAlien             |\n//+------------------------------------------------------------------+\n#property copyright "2020-2025 treebourks-debug"\n#property link      "https://github.com/treebourks-debug/Moving-Average-EA-conversion-from-MT4_The-Alien"\n#property version   "3.00"\n#property description "Moving Average improved EA with risk management, ATR & trend filters."\n\n#include <Trade\Trade.mqh>\n\n#define MAGICMA  20131111\n\n//--- Inputs\ninput double FixedLots            = 0.0;    // Fixed lot size (0=use risk %)\ninput double RiskPercent          = 1.0;    // Risk per trade in %\ninput double MaximumRisk          = 0.02;   // Maximum risk per trade (not used by default)\ninput double DecreaseFactor       = 3.0;    // Decrease factor after losses\n\ninput int    FastMA_Period        = 10;     // Fast MA Period\ninput int    SlowMA_Period        = 40;     // Slow MA Period\ninput ENUM_MA_METHOD MA_Method    = MODE_EMA; // MA Method\ninput int    MovingShift          = 6;      // MA Shift\n\ninput int    StopLoss             = 300;    // Stop Loss in points\ninput int    TakeProfit           = 0;      // Take Profit in points (0=use RiskReward)\ninput double RiskReward           = 2.0;    // Risk/Reward Ratio (0=use TP)\n\ninput bool   UseTrailingStop      = false;  // Use Trailing Stop\ninput int    TrailingStop         = 300;    // Trailing Stop in points\ninput int    TrailingStep         = 100;    // Trailing Step in points\n\ninput int    MaxSpread            = 30;     // Maximum spread (0=no limit)\ninput bool   UseATRFilter         = true;   // Use ATR volatility filter\ninput int    ATR_Period           = 14;     // ATR Period\ninput double ATR_MinValue        = 100.0;   // Minimum ATR value in points\ninput int    MinBarsBetween      = 3;       // Min bars between trades\ninput bool   UseTrendFilter      = true;    // Only trade with trend\n\ninput double MaxDailyLoss        = 0.0;     // Max daily loss in account currency (0=disabled)\ninput int    MaxOpenTrades       = 1;       // Maximum open trades per symbol\n\ninput bool   EnableDebug         = true;    // Enable debug messages\n\n//--- Global variables\nCTrade trade;\nint    fast_ma_handle = INVALID_HANDLE, slow_ma_handle = INVALID_HANDLE, atr_handle = INVALID_HANDLE;\ndouble fast_ma[], slow_ma[], atr[];\ndatetime last_bar_time = 0;\ndatetime last_trade_time = 0;\ndouble daily_profit = 0.0;\ndatetime current_day = 0;\n\n//+------------------------------------------------------------------+\n//| Expert initialization function                                   |\n//+------------------------------------------------------------------+\nint OnInit()\n  {\n   if(EnableDebug) Print("=== TheAlien EA initializing ===");\n\n   // create indicators\n   fast_ma_handle = iMA(_Symbol, _Period, FastMA_Period, MovingShift, MA_Method, PRICE_CLOSE);\n   slow_ma_handle = iMA(_Symbol, _Period, SlowMA_Period, MovingShift, MA_Method, PRICE_CLOSE);\n   atr_handle     = iATR(_Symbol, _Period, ATR_Period);\n\n   if(fast_ma_handle==INVALID_HANDLE || slow_ma_handle==INVALID_HANDLE || atr_handle==INVALID_HANDLE)\n     {\n      Print("ERROR: Cannot create indicator handles");\n      return(INIT_FAILED);\n     }\n\n   trade.SetExpertMagicNumber(MAGICMA);\n   trade.SetDeviationInPoints(50);\n   trade.SetAsyncMode(false);\n\n   ArraySetAsSeries(fast_ma,true);\n   ArraySetAsSeries(slow_ma,true);\n   ArraySetAsSeries(atr,true);\n\n   last_bar_time = 0;\n   last_trade_time = 0;\n   daily_profit = 0.0;\n   current_day = 0;\n\n   if(EnableDebug) Print("EA initialized successfully");\n   return(INIT_SUCCEEDED);\n  }\n\n//+------------------------------------------------------------------+\n//| Deinitialization                                                 |\n//+------------------------------------------------------------------+\nvoid OnDeinit(const int reason)\n  {\n   if(fast_ma_handle!=INVALID_HANDLE) IndicatorRelease(fast_ma_handle);\n   if(slow_ma_handle!=INVALID_HANDLE) IndicatorRelease(slow_ma_handle);\n   if(atr_handle!=INVALID_HANDLE) IndicatorRelease(atr_handle);\n   if(EnableDebug) Print("EA deinitialized");\n  }\n\n//+------------------------------------------------------------------+\n//| Helper: Get filling mode                                          |\n//+------------------------------------------------------------------+\nENUM_ORDER_TYPE_FILLING GetFillingMode(string symbol)\n  {\n   int filling = (int)SymbolInfoInteger(symbol, SYMBOL_FILLING_MODE);\n   if((filling & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK) return ORDER_FILLING_FOK;\n   if((filling & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC) return ORDER_FILLING_IOC;\n   return ORDER_FILLING_RETURN;\n  }\n\n//+------------------------------------------------------------------+\n//| Calculate lot size based on risk                                 |\n//+------------------------------------------------------------------+\ndouble CalculateLotSize(double sl_points)\n  {\n   if(FixedLots > 0.0) return(NormalizeDouble(FixedLots,2));\n\n   double balance = AccountInfoDouble(ACCOUNT_BALANCE);\n   double risk_money = balance * RiskPercent / 100.0;\n\n   double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);\n   double tick_size  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);\n   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);\n\n   if(tick_value<=0 || tick_size<=0)\n     {\n      // fallback\n      double minlot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);\n      return(minlot);\n     }\n\n   double lot = (risk_money / (sl_points * point / tick_size * tick_value));\n   double lotstep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);\n   double minlot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);\n   double maxlot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);\n\n   if(lotstep <= 0) lotstep = 0.01;\n   lot = MathFloor(lot/lotstep) * lotstep;\n   if(lot < minlot) lot = minlot;\n   if(lot > maxlot) lot = maxlot;\n\n   return(NormalizeDouble(lot,2));\n  }\n\n//+------------------------------------------------------------------+\n//| Check daily loss limits                                           |\n//+------------------------------------------------------------------+\nbool CheckDailyLimits()\n  {\n   if(MaxDailyLoss <= 0.0) return true;\n\n   MqlDateTime tm;\n   TimeCurrent(tm);\n   datetime today = StringToTime(IntegerToString(tm.year)+"."+IntegerToString(tm.mon)+"."+IntegerToString(tm.day));\n\n   if(current_day != today)\n     {\n      current_day = today;\n      daily_profit = 0.0;\n     }\n\n   // compute daily realized P/L for this EA\n   HistorySelect(today, TimeCurrent());\n   int total = HistoryDealsTotal();\n   daily_profit = 0.0;\n   for(int i=0;i<total;i++)\n     {\n      ulong ticket = HistoryDealGetTicket(i);\n      if(ticket==0) continue;\n      string sym = HistoryDealGetString(ticket, DEAL_SYMBOL);\n      if(sym != _Symbol) continue;\n      if(HistoryDealGetInteger(ticket, DEAL_MAGIC) != MAGICMA) continue;\n      int entry = (int)HistoryDealGetInteger(ticket, DEAL_ENTRY);\n      if(entry == DEAL_ENTRY_OUT)\n         daily_profit += HistoryDealGetDouble(ticket, DEAL_PROFIT);\n     }\n\n   if(daily_profit < -MaxDailyLoss)\n     {\n      if(EnableDebug) Print("Daily loss limit reached: ", daily_profit);\n      return false;\n     }\n   return true;\n  }\n\n//+------------------------------------------------------------------+\n//| OnTick                                                            |\n//+------------------------------------------------------------------+\nvoid OnTick()\n  {\n   // trade checks\n   if(Bars(_Symbol, _Period) < 100) return;\n   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) return;\n   if(!MQLInfoInteger(MQL_TRADE_ALLOWED)) return;\n\n   // new bar check\n   datetime cur_time = iTime(_Symbol, _Period, 0);\n   if(last_bar_time == cur_time) return;\n   last_bar_time = cur_time;\n\n   // copy indicators\n   if(CopyBuffer(fast_ma_handle,0,0,3,fast_ma) < 3) { Print("CopyBuffer fast failed"); return; }\n   if(CopyBuffer(slow_ma_handle,0,0,3,slow_ma) < 3) { Print("CopyBuffer slow failed"); return; }\n   if(UseATRFilter)\n     {\n      if(CopyBuffer(atr_handle,0,0,1,atr) < 1) { Print("CopyBuffer ATR failed"); return; }\n     }\n\n   // ATR filter\n   if(UseATRFilter)\n     {\n      double atrval = atr[0] / SymbolInfoDouble(_Symbol, SYMBOL_POINT); // pts\n      if(atrval < ATR_MinValue)\n        {\n         if(EnableDebug) Print("ATR too low: ", atrval);\n         return;\n        }\n     }\n\n   // spread filter\n   if(MaxSpread > 0)\n     {\n      long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);\n      if(spread > MaxSpread)\n        {\n         if(EnableDebug) Print("Spread too high: ", spread);\n         return;\n        }\n     }\n\n   // daily limits and max open trades check\n   if(!CheckDailyLimits()) return;\n   if(CountPositions() >= MaxOpenTrades) return;\n\n   // trend filter\n   bool uptrend = fast_ma[0] > slow_ma[0];\n   bool downtrend = fast_ma[0] < slow_ma[0];\n   if(UseTrendFilter && !uptrend && !downtrend) return;\n\n   // signals: crossover of fast vs slow (bar 1 -> bar 0)\n   bool buy_signal = fast_ma[1] <= slow_ma[1] && fast_ma[0] > slow_ma[0];\n   bool sell_signal = fast_ma[1] >= slow_ma[1] && fast_ma[0] < slow_ma[0];\n\n   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);\n   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);\n\n   // close on reverse signals\n   CheckForClose();\n\n   if(HasOpenPosition()) return;\n\n   // calculate lots based on SL\n   double sl_pts = StopLoss;\n   if(sl_pts <= 0) sl_pts = 100; // fallback\n   double lot = CalculateLotSize(sl_pts);\n\n   // SL/TP values\n   double sl_buy=0, tp_buy=0, sl_sell=0, tp_sell=0;\n   if(StopLoss>0)\n     {\n      sl_buy = ask - StopLoss * point;\n      sl_sell = bid + StopLoss * point;\n     }\n   if(RiskReward>0)\n     {\n      tp_buy = ask + StopLoss * RiskReward * point;\n      tp_sell = bid - StopLoss * RiskReward * point;\n     }\n   else if(TakeProfit>0)\n     {\n      tp_buy = ask + TakeProfit * point;\n      tp_sell = bid - TakeProfit * point;\n     }\n\n   // execute trades\n   if(buy_signal)\n     {\n      if(EnableDebug) Print("BUY signal, lot=",lot);\n      if(trade.Buy(lot,_Symbol,ask,sl_buy,tp_buy,"MA_Buy"))\n        {\n         if(EnableDebug) Print("Buy placed, ticket=",trade.ResultOrder());\n         last_trade_time = TimeCurrent();\n        }\n     }\n   else if(sell_signal)\n     {\n      if(EnableDebug) Print("SELL signal, lot=",lot);\n      if(trade.Sell(lot,_Symbol,bid,sl_sell,tp_sell,"MA_Sell"))\n        {\n         if(EnableDebug) Print("Sell placed, ticket=",trade.ResultOrder());\n         last_trade_time = TimeCurrent();\n        }\n     }\n  }\n\n//+------------------------------------------------------------------+\n//| Count open positions for this EA                                 |\n//+------------------------------------------------------------------+\nint CountPositions()\n  {\n   int cnt=0;\n   for(int i=PositionsTotal()-1;i>=0;i--)\n     {\n      if(PositionGetTicket(i)==0) continue;\n      if(PositionGetString(POSITION_SYMBOL)==_Symbol && PositionGetInteger(POSITION_MAGIC)==MAGICMA) cnt++;\n     }\n   return cnt;\n  }\n\n//+------------------------------------------------------------------+\n//| Check if there is any open position                              |\n//+------------------------------------------------------------------+\nbool HasOpenPosition()\n  {\n   return (CountPositions()>0);\n  }\n\n//+------------------------------------------------------------------+\n//| Close positions on reverse signals                                |\n//+------------------------------------------------------------------+\nvoid CheckForClose()\n  {\n   MqlRates rates[];\n   ArraySetAsSeries(rates,true);\n   if(CopyRates(_Symbol,_Period,0,2,rates) < 2) return;\n   double open1 = rates[1].open;\n   double close1 = rates[1].close;\n\n   for(int i=PositionsTotal()-1;i>=0;i--)\n     {\n      ulong ticket = PositionGetTicket(i);\n      if(ticket==0) continue;\n      if(PositionGetString(POSITION_SYMBOL)!=_Symbol) continue;\n      if(PositionGetInteger(POSITION_MAGIC)!=MAGICMA) continue;\n\n      int ptype = (int)PositionGetInteger(POSITION_TYPE);\n      if(ptype==POSITION_TYPE_BUY)\n        {\n         if(open1 > fast_ma[1] && close1 < fast_ma[1])\n            trade.PositionClose(ticket);\n        }\n      else if(ptype==POSITION_TYPE_SELL)\n        {\n         if(open1 < fast_ma[1] && close1 > fast_ma[1])\n            trade.PositionClose(ticket);\n        }\n     }\n  }\n//+------------------------------------------------------------------+\n